# 개인 메모:
시프트 연산(shift operation), in 연산자, is 연산자는 각각 다른 기능을 가지고 있습니다.

시프트 연산(shift operation)은 비트(bit) 단위로 이동(shift)하는 연산입니다. 파이썬에서는 비트 단위 시프트 연산자 <<와 >>를 제공합니다. 왼쪽 시프트 연산자 <<는 비트열을 왼쪽으로 이동시키는 연산이며, 오른쪽 시프트 연산자 >>는 비트열을 오른쪽으로 이동시키는 연산입니다.

예를 들어, a = 0b1100이라고 할 때, a << 2를 하면 0b110000이 되고, a >> 1을 하면 0b0110이 됩니다.

in 연산자는 시퀀스(sequence) 자료형 안에 어떤 값이 있는지를 검사하여 True나 False를 반환하는 연산자입니다. 시퀀스 자료형에는 리스트(list), 튜플(tuple), 문자열(string), 셋(set) 등이 있습니다. in 연산자는 해당 값이 시퀀스 자료형 안에 있으면 True를, 없으면 False를 반환합니다.

예를 들어, 다음과 같은 리스트가 있을 때, 2 in [1, 2, 3]은 True를 반환하고, 4 in [1, 2, 3]은 False를 반환합니다.

is 연산자는 두 개의 객체가 동일한 객체인지를 검사하는 연산자입니다. is 연산자는 객체의 식별 번호(identity)를 비교합니다. 즉, 두 객체의 메모리 주소가 같은지를 비교합니다. 따라서 is 연산자는 객체의 값이 같은지를 비교하는 것이 아니라, 객체 자체가 같은 객체인지를 비교합니다.

예를 들어, a = [1, 2, 3]이라고 할 때, b = a라고 하면 b is a는 True를 반환합니다. 이는 b가 a와 같은 리스트 객체를 참조하고 있기 때문입니다. 반면, b = [1, 2, 3]이라고 할 때, b is a는 False를 반환합니다. 이는 b와 a가 서로 다른 리스트 객체를 참조하고 있기 때문입니다.

# test_func.py
이 코드는 파이썬에서 중첩 함수(nested function)를 이용하여 클로저(closure)를 생성하는 예제입니다.

함수 배수(n)은 인자 n을 받아서 새로운 함수 적립(value)를 내부에서 정의하고, 이를 반환합니다. 함수 적립(value)는 인자 value에 10%를 곱한 값에 n을 곱한 값을 반환합니다.

그리고 Feb = 배수(2)를 호출하면 Feb라는 변수에 n 값이 2인 적립(value) 함수가 저장됩니다. 마찬가지로 Mar = 배수(3)를 호출하면 Mar 변수에 n 값이 3인 적립(value) 함수가 저장됩니다.

따라서 Feb(5000)은 value에 5000을 대입하여 (5000 * 0.1) * 2 즉, 1000을 반환합니다. 마찬가지로 Mar(15000)은 value에 15000을 대입하여 (15000 * 0.1) * 3 즉, 4500을 반환합니다.

따라서 print(Feb(5000))은 1000을 출력하고, print(Mar(15000))은 4500을 출력합니다.

# test_func_second.py

이 코드는 A등급, B등급, C등급의 물건 개수에 따라 총 가격을 계산하고, 총 가격이 10000원 이상일 경우 10% 할인된 가격을 출력하며, 10000원 미만일 경우 총 가격을 출력합니다.

여기서 `총합 = 계산(1, 2, 3)`은 A등급 물건 1개, B등급 물건 2개, C등급 물건 3개가 있을 때의 가격을 계산하고 그 결과를 `총합` 변수에 저장하는 것입니다. 

따라서 `총합` 변수의 값은 `a * 가격['A등급'] + b * 가격['B등급'] + c * 가격['C등급']` 의 결과값, 즉 1 * 1000 + 2 * 500 + 3 * 100 = 2300 입니다.

따라서 `총합` 값이 10000 이상인 경우에는 할인된 가격인 `총합 * 0.9` 를 출력하며, 10000 미만인 경우에는 `총합` 값을 출력합니다.